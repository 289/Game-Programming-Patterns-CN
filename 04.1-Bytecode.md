字节码
============================

## 意图
通过将行为编码成虚拟机指令，而使其具备数据的灵活性。

## 动机

> 我曾参与一款有600万行C++代码的游戏。比较起来火星探测车“好奇号”的控制软件的代码量还不及它的一半。

制作游戏很有趣，但也不容易。现在的游戏需要庞大复杂的数据库。主机厂商和应用商店有严格的质量要求，一个造成崩溃的Bug就可能导致你的游戏无法发布。

与此同时，我们期许能榨干平台所能提供的全部性能。我们要不遗余力地进行优化，以跟上游戏所推动硬件进步。

为了获得高稳定性和效率，我们会选择像C++这样的重量级语言。它们兼具充分利用硬件的能力以及可以阻止或拦截Bug的强类型系统。

我们可以为此感到骄傲，但它也有代价。多年的专业训练才能造就一个精通的程序员，随后你又必须面对庞大的代码库。大型游戏的编译时间可以短到“喝杯咖啡”，也可以长到“自己煮咖啡豆、磨咖啡豆、倒咖啡、打奶泡、练练拿铁的拉花”。

除了这些挑战外，游戏还有个讨厌的约束：有趣。玩家需要的是既新奇又具平衡性的体验。这就需要持续迭代。如果每个小修小改都都得一个工程师去动底层代码，然后等待漫长的重编译，那实际上你已经毁了整个创作流程。

### 魔法大战！
比如说，我们在开发一款基于魔法的战斗游戏。两个对峙的法师不断向对方丢法术，直到其中一个取得胜利。我们可以在代码中定义法术，但这意味着每次修改都需要工程师介入。当一个设计师想要改些数字，试试感觉，这需要重新编译整个游戏，重启然后重新进入战斗。

在游戏发布之后，我们得像其他游戏一样去更新它，包括修正Bug以及添加内容等。如果所有的法术都被硬编码，一次更新就等价于发一次可执行文件的补丁。

进一步来说，如果要支持MOD，要让用户自己创建法术。如果它们都在代码里面，那这些用户都需要有完整的编译工具链去构建游戏，我们得公开所有源码。况且，如果他们的法术有Bug，其他玩家可能受到殃及而造成游戏崩溃。


### Data > code
很明显，我们引擎所使用的编程语言不适合解决这个问题。我们需要把法术从游戏核心移动到安全沙箱中。我们要给让它们易于修改，易于重新加载并且在物理上与游戏的可执行文件相分离。

我不知道你怎么看，这种形式在我看来更像是种*数据*。我们可以在单独的数据文件中定义行为，游戏引擎可以以某种方式加载并“执行”它们。这样一来就达到了我们的目的。

我们只需要弄明白“执行”这些数据的方法。怎样才能让文件中的字节表示行为呢？有好几种方法。参照一下[解释器](http://en.wikipedia.org/wiki/Interpreter_pattern)模式，你就能对此模式的优缺点全貌有个大致了解。

### 解释器模式
本来这个模式我可以写成一整章的，但是有四个家伙已经替我说了。所以，这里我仅做一些简介。我们从一个语言开始——你可以类比编程语言——你要去执行它。举个例子。它支持下面的数学表达式：

```c++
(1 + 2) * (3 - 4)
```

然后，你拿出表达式中的每个片段、语言语法中的每个规则，将它们变成对象。数字的对象就是它们的字面值。

![](./res/bytecode-numbers.png)

简单来说，它们是在原始数值的基础上，做了个小封装。运算符也是对象，它们拥有对操作数的引用。如果你使用括号来控制优先级的话，这个表达式又变成了一棵小对象树：

> 这个“变化”究竟是什么？很简单——解析。解析器接受输入文本字符串，然后将它变成抽象的语法树，即一组用于表示文本语法结构的对象。

> 把上述内容堆积起来，你就拥有了半个编译器。

![](./res/bytecode-ast.png)

解释器模式与创建语法树无关，它只关心如何执行它。它的处理很聪明，树中的每个对象都是表达式或子表达式。在面向对象风格中，表达式会计算它们自己的值。

首先，定义一个所有表达式都要实现的基础接口。

```c++
class Expression
{
public:
  virtual ~Expression() {}
  virtual double evaluate() = 0;
};
```

然后为每一个语法定义实现这个接口的类。其中，最简单的是数字：
```c++
class NumberExpression : public Expression
{
public:
  NumberExpression(double value)
  : value_(value)
  {}

  virtual double evaluate()
  {
    return value_;
  }

private:
  double value_;
};
```

一个字面数字表达式的值就等同于它的数值。加法和乘法要稍微复杂一些，因为他们包含子表达式。它们需要先递归计算出所有子表达式的值，之后才能计算出它们自己的值。像这样：

```c++
class AdditionExpression : public Expression
{
public:
  AdditionExpression(Expression* left, Expression* right)
  : left_(left),
    right_(right)
  {}

  virtual double evaluate()
  {
    // Evaluate the operands.
    double left = left_->evaluate();
    double right = right_->evaluate();

    // Add them.
    return left + right;
  }

private:
  Expression* left_;
  Expression* right_;
};
```

显然，只要几个简单的类，就能够表达任何复杂的算术表达式了。我们只用创建几个对象，并将它们正确得关联起来。

> Ruby在大概15年前就是这么实现的。到了1.9版本，它们改成了本章所说的字节码。看我替你省了多少时间！

这个模式虽然简单漂亮，但是也有些问题。回头看看上面的插图，你看到了些什么？很多小盒子，以及它们之间的箭头。代码用一个微小对象构成的曼生分形树来表达，会造成一些很不舒服的结果：
- 从磁盘加载需要实例化并串联成堆的小对象。
> 如果你想自己算算的话，别忘了算上虚函数表。
- 些对象和它们之间的指针占用大量内存。在32位机上，即使不考虑对其，这个小小的表达式也要占用68字节。
> 要了解更多关于缓存以及它如何影响性能的原理，看看[数据局部性](06.1-Data%20Locality.md)这一章。
- 从每个指针遍历出表达式会杀了你的数据缓存，而虚函数调用也会对指令缓存造成很大压力。

总结一下，该怎么说呢？慢啊！大量的编程语言不采用解释器模式，就是因为它又慢又占内存。

### 虚拟机器码
回到我们的游戏。当它运行的时候，玩家的电脑不会在运行时遍历一个C++语法结构树。我们已经提前将它编译成CPU可以直接执行的机器码了。那么为什么要采用机器码呢？
- 高密度。它是坚实持续的数据块，不会浪费任何一个bit。
- 线性。指令被打包在一起顺序执行。不会在内存中跳跃访问（当然了，除非你确实在做流程控制）
- 底层。每个单独的执行都只做一件小事，各种有趣行为都是它们的组合。
- 高速。综上所述（当然还得算上机器码由硬件实现这一点了），机器码跑起来像风一样。

听上去不错，但我们不想用机器码去编写各种法术。让用户提供在游戏里执行的机器码，简直是自找麻烦，这会带来很多安全问题。我们只能在机器码的效率和解释器模式的安全性之间取一个平衡。

> 这就是为什么很多主机和iOS禁止程序在运行时生成或载入机器码的原因。这是个拖后腿的规定，因为最快的编程语言就是基于这个原理实现的。它们包含一个“just-in-time”编译器，或者叫JIT。它能飞快地把语言翻译成优化的机器码。

我们不要去加载执行真正的机器码，而去定义自己的虚拟机器码，会怎样呢？我们会在游戏中实现一个模拟器。它于机器码相似——高密度、线性、相对底层——同时它完全接受游戏安全的管理。

> 在编程语言的语境下，“虚拟机”和“解释器”都有自己的含义，这里我把它们穿插进来了。如果要说四人帮的解释器模式的话，我会强调“模式”这个词，以避免混淆。
我们将这个小模拟器称为虚拟机（简称VM），这个虚拟机所执行的二进制“机器码”称为字节码。它具备从数据定义事物的灵活性和易用性，它也比解释器模式这种高级呈现方式更高效。

听上去挺吓人的。我在本章里剩下的目标，就是要给你展示一下，如果你控制好自己的功能清单，这个方案非常可行。即使最终你自己也没把这个模式用起来，至少你能对Lua以及别的采用这个原理的语言有更好的了解。

## 模式
**指令集**定义可以执行的底层操作。用**字节序列**来定义它。**虚拟机**逐条执行指令栈上的指令。通过组合指令，可以获得很多高级行为。

## 何时使用它
这是本书中最复杂的模式，要把它放进你的游戏里没那么容易。仅当你的游戏中需要定义大量行为，并且它的编程语言没法处理好下列事情时：
- 编程语言太底层了，编写起来繁琐易错
- 因编译时间太长或工具问题，导致迭代缓慢
- 它太相信编码者。你想确保定义的行为不会让程序崩溃，就得把它们放进安全沙箱里。
当然，这个列表符合大多数游戏的情况。谁不想提高迭代速度，让程序更安全？但那是1有代价的。字节码比本地码要慢，所以它并不适合用作对性能要求极高的核心部分。

## 注意
> 对我来说游戏开发有同样的吸引力，我在努力创建虚拟世界，让别人进来玩或做创意。
建立你自己的语言或内嵌系统是一件很有吸引力的事。这里我只做个最小化示例，但在现实中，它会像野草一样疯长。

> 比如所有的模板语言
每次我看到有人定义一中小语言或脚本，他们会说“别担心，它会很小巧”。没法控制的是，他们会不断往里面添加小功能，直到它变成一个成熟的语言。但不像其他语言，它的发展是一些临时功能的有机组合，就像个精致的棚屋小镇。


当然，做个成熟的语言没什么错。只要保证你目标明确。否则，就控制好你的字节码要表达的东西，在它超出你控制之前设定好范围。

### 你需要个前端
低级的字节码对性能提升很大，但你没法让你的用户直接编写它们。我们将行为从代码中移出来的一个原因是想要用更高级的方式表达它。C++已经很底层了，如果想让你的用户高效得编写汇编——这根本不是种进步！

>  一个反例是有名的[RoboWar](http://en.wikipedia.org/wiki/RoboWar)。在这个游戏里，玩家使用一种类似汇编的语言编写小程序，来控制机器人。我们这里也会讨论指令集这种方式。
> 这是我的第一篇汇编类语言的指南。

就像四人帮的解释器模式一样，它假定你能够以某种方式生成字节码。通常，用户会在更高级的层次上编辑，一个工具负责将它转换成虚拟机能够理解的字节码。这个工具的名字，就是编译器。

我知道，听上去很可怕对不对。所以这里我先提出来了。如果你没有足够的资源去完成一个编辑工具，那么字节码不适合你。但你先别急继续往下看，也许没你想象中那么坏。

### 你会想念调试器的
编程很难。我们知道自己想让机器做什么，但是我们很难用正确的方式与之沟通——我们会写出bug。为此，我们搜集了一大堆工具来找出代码错在哪里，如何去改正。我们有调试器、静态分析器、反编译工具等等。所有这些工具都是为某种已经存在的语言而设计的：机器码或者是高级语言。

当你定义自己的字节码虚拟机时，你就没法用这些工具了。当然了，你可以用调试器步进到虚拟机的代码里，但那只能告诉你虚拟机在做什么，与它正在解释的字节码没什么关系。它也没法替你把字节码映射回对应的原始高级语言。

如果你定义的行为很简单，你可以勉强回避掉做各种辅助调试工具的事儿。但是随着内容规模增长，你得规划好如何让用户能实时看到他们的字节码有什么效果。这些功能可能不会随游戏发布，但是它们能确保你的游戏可以发布。

> 当然，如果你想让游戏支持MOD，你就得发布这些功能，这相当重要。

## 简单的代码
在上面几节讨结束之后，你可能会很好奇如何直接实现它。首先，要为虚拟机设计一个指令集。在真正考虑，字节码之类的东西前，可以先把它们当成是API。


