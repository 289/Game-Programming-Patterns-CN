子类沙盒
============================

#目的
使用一个基类提供的操作集合进而在子类中定义行为

#动机
每个小孩都有一个成为超级英雄的梦想，但是很不幸，宇宙射线在地球上供应不足。游戏能够让你无限逼真的模拟成为一个超级英雄。因为我们得游戏设计师从来不会说，“不”， 我们的超级英雄游戏没有数百也起码有数十种不同种类英雄需要的超级力量。

我们的计划是我们将有一个Superpower基类，然后，我们将有一个实现各个超级力量的继承类。我们将在团队中的程序员中分摊设计文档并进行编码。当我们完成的时候，我们将有一百个超级力量的类。

> 注解

> 当你发现自己像这个例子一样有大量的子类的时候，这意味着一种数据驱动的方法可能更适合。试着找到一种定义数据的行为的方法，而不是用大量的代码来定义不同的力量。

> 像模式Type Object, Bytecode 和 Interpreter 或许能有所帮助。

我们想让我们的玩家沉寖在一个复杂多变的世界里。无论他们小时候梦想过的什么力量，在我们的游戏我们都需要。这就意味着这些超级力量子类能够几乎做任何事情：播放音效，产生视觉效果，与AI交互，创建和销毁其他游戏实体以及产生物理效果。他们可以使用任何的代码库。

让我们释放我们的队伍，让他们写超级力量的类的话，会发生什么呢？

- 会充满大量的冗余代码。由于不同的力量将有所不同，我们可以预料到大量的重复。他们中的许多将以同样的方式来产生视觉效果和播放音效。当你完成冰冻射线，热射线，第戎芥末射线这些射线时，会发现他们极其相似。如果人们在实现它们时没有整合起来，那么将会有大量的冗余代码和付出。

- 游戏引擎的每个部分将与这些类产生耦合。在没有更好方法的前提下，人们将写出调用子系统的代码，这些子系统从来不打算与超级类直接绑定。如果我们的渲染器被组织成一些漂亮优雅的分层，只有其中的一层能够被图形引擎之外的代码使用，我们可以打赌最后将留下侵入到他们所有层的超级力量代码。

- 当这些外部系统需要改变的时候，任意的一些超级力量代码将有很大的概率被破坏。一旦我们的不同种类的超级力量类与游戏引擎的各式各样的部分产生耦合的时候，必然发生的是改变这些系统将影响力量类。这将是很无趣的，因为你的图形，音效，UI程序员可能并不想非得是游戏程序员。

- 定义所有超级力量遵守的约束条件将是困难的。例如说我们想保证所有我们超级力量播放的音效得到合理的排队和优先级处理。如果我们一百个类都自己直接地条用音效引擎的话，这将是很难实现的。

我们需要的是给每个实现一个超级力量的游戏程序员一系列可用的基本元。你想要你的力量播放音效吗？这里提供你的playSound()函数。你想要粒子效果吗？这里有spawnParticles()。我们将保证这些操作覆盖你所有的需求，这样一来你就不用#include任意的头文件以及探入代码库的余下部分。

我们通过把这些操作设置成Superpower基类的保护方法来实现这种效果。把他们放在基类就能让每一个力量子类直接简单地访问方法。把他们设置为保护状态(并且可能非虚拟的)通讯，这样他们就针对性地被子类调用。

一旦我们有了这些可玩的玩具，我们需要一个地方来使用它们。因此，我们将定义一个沙盒方法，这是一个子类必须实现的抽象保护方法。在有了这些之后，为了实现一种新的力量，你：

1. 创建一个继承自Superpower的新类。
2. 覆盖沙盒函数activate()。
3. 通过调用Superpower提供的保护函数来实现沙盒函数的函数体。

我们现在能够通过使这些操作尽可能的高层来解决代码冗余的问题。当我们发现在大量子类中存在重复代码，我们可以把它向上移到Superpower中作为一个可用的新操作。

我们已经通过把耦合限制在一个地方来解决耦合问题。Superpower最终将与不同的游戏系统耦合，但是我们的一百个子类不会。反而，他们仅仅与基类耦合。当这些游戏系统中的一个变化时，对Superpower进行修改可能是必须的，但是这些大量的子类不应被动。

这个设计模式会催生一种浅而宽的类层次架构。你的继承链不会深，但是会有大量的类挂在Superpower上。通过生成一个有大量直接子类的单个类，我们在代码库里就有只有一个点的杠杆。我们在Superpower中所付出的时间和关爱都将对游戏中大量的类带来益处。

> 注解

> 近来，你发现人们对面向对象语言的继承进行批判。继承是有问题的 -- 在代码库中没有比基类与子类之间更深的耦合了 -- 但是我发现宽的继承树比深的要表现的更好。

#模式
一个__基类__定义了一个抽象的__沙盒方法__和一些__提供的操作__。通过设置他们为保护状态能够明确他们是被子类使用。每个继承的__沙盒子类__通过提供的操作来实现沙盒函数。

#什么时候使用
沙盒模式是一种运用在大量代码库里甚至游戏之外的非常简单通用的模式。如果你有一个非虚拟的保护函数，那么你很有可能正在使用类似该模式的东西。沙盒模式在以下情况比较适用：

- 你有一个带有大量子类的基类。

- 基类能够提供一个子类需要执行的所有操作。

- 在子类之间有重叠的代码，你想让他们之间更容易地分享代码。

- 你想使这些继承类以及程序的其他代码之间的耦合最小化。

#记住
“继承”一词最近在一些程序圈子里被视为诟病，其中一个原因是基类会越来越增长。
